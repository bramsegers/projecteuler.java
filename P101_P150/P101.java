package P101_P150;

/*
 * If we are presented with the first k terms of a sequence it is impossible to say 
 * with certainty the value of the next term, as there are infinitely many polynomial 
 * functions that can model the sequence.
 * 
 * As an example, let us consider the sequence of cube numbers. This is defined by the 
 * generating function  u(n)=n^3:   1, 8, 27, 64, 125, 216, ...
 * Suppose we were only given the first two terms of this sequence. We assume a linear 
 * relationship and predict the next term to be 15 (common difference 7). Even if we were 
 * presented with the first three terms, a quadratic relationship should be assumed.
 * 
 * We shall define OP(k,n) to be the nth term of the optimum polynomial generating 
 * function for the first k terms of a sequence. It should be clear that OP(k,n) will 
 * accurately generate the terms of the sequence for n <= k, and potentially the first 
 * incorrect term (FIT) will be OP(k,k+1); in which case we shall call it a bad OP (BOP).
 * 
 * As a basis, if we were only given the first term of sequence, it would be most sensible 
 * to assume constancy; that is, for n >= 2, OP(1,n) = u(1).
 * 
 * Hence we obtain the following OPs for the cubic sequence:
 * OP(1,n) = 1                 1, [1], 1, 1, ...
 * OP(2,n) = 7n + 6            1, 8, [15], ...
 * OP(3,n) = 6n^2 - 11n + 6    1, 8, 27, [58], ...
 * OP(4,n) = n^3               1, 8, 27, 64, 125, ...
 * Clearly no BOPs exist for k >= 4.
 * 
 * By considering the sum of FITs generated by the BOPs (indicated between [] above), 
 * we obtain 1 + 15 + 58 = 74.
 * 
 * Consider the following tenth degree polynomial generating function:
 * u(n) = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10
 * Find the sum of FITs for the BOPs.
 * 
 * Info: http://en.wikipedia.org/wiki/Lagrange_polynomials
 */
public class P101 {

    public static long solve() {
        long sum = 0;
        for (int n = 0; n <= 10; n++) {
            System.out.println("u(" + (n + 1) + ")=" + u(n + 1));
        }
        for (int i = 0; i <= 10; i++) {
            System.out.print(i + "th degree: ");
            long lag;
            int j = 0;
            while (j++ <= 10 && (lag = L(i + 1, j)) == u(j)) {
                System.out.print(lag + ", ");
            }
            long fit = (i == 10) ? 0 : L(i + 1, j);
            System.out.println((i == 10) ? "[no fit]" : "[fit = " + fit + "]");
            sum += fit;
        }
        return sum;
    }

    private static long L(int i, int j) {
        long rv = 0;
        for (int k = 1; k <= i; k++) {
            long num = u(k);
            long denom = 1;
            for (int m = 1; m <= i; m++) {
                num *= (k == m) ? 1 : j - m;
                denom *= (k == m) ? 1 : k - m;
            }
            rv += num / denom;
        }
        return rv;
    }

    private static long u(long n) {
        return 1
                - n
                + n * n
                - n * n * n
                + n * n * n * n
                - n * n * n * n * n
                + n * n * n * n * n * n
                - n * n * n * n * n * n * n
                + n * n * n * n * n * n * n * n
                - n * n * n * n * n * n * n * n * n
                + n * n * n * n * n * n * n * n * n * n;
    }

    public static void main(String[] args) {
        System.out.println(P101.solve());
    }
}
